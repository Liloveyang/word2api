package org.oscarlab.word2api;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class W2ASimilarity {

	private Map<String, Double[]> termVecMap = null;
	
	/**
	 * Load the vector dictionary into HashMap.
	 * Each key represents a term and each value means the term vector.
	 * The terms have been stemmed by Porter Stemming algorithm.
	 * @param path	dictionary path
	 * @return	a hash map.
	 * @throws IOException
	 */
	public void loadVecDictionary(String path) throws IOException {
		
		termVecMap = new HashMap<String, Double[]>();
		
		BufferedReader br = new BufferedReader(new FileReader(new File(path)));
		String line = "";
		br.readLine();	// skip the first line. This line is the basic information of the dictionary.
		while (null != (line = br.readLine())) {
			String[] array = line.split(" ");
			String term = array[0];
			String[] values = Arrays.copyOfRange(array, 1, array.length);
			Double[] tmp = new Double[values.length];
			for (int i = 0; i < values.length; ++i) {
				tmp[i] = Double.valueOf(values[i]);
			}
			termVecMap.put(term, tmp);	// put word and its vector into HashMap.
		}
		br.close();
	}
	
	/**
	 * Calculate the similarity between two low-dimensional vectors generated by word2api
	 * @param vec1	the first vector
	 * @param vec2	the second vector
	 * @return	the consin similarity of the two vectors
	 */
	private double getVecSimilairty(Double[] vec1, Double[] vec2) {
		
		double a = 0, b = 0, c = 0;
		for (int i = 0; i < vec1.length; ++i) {
			a += vec1[i] * vec2[i];
			b += vec1[i] * vec1[i];
			c += vec2[i] * vec2[i];
		}
		if (b != 0 && c != 0) {
			return a / (Math.sqrt(b)*Math.sqrt(c));
		} else {
			return 0;
		}
	}
	
	/**
	 * Calculate the similarity between a word and an API
	 * @param word	the word. Word should not be stemmed.
	 * @param api	the API (package_name#method_name).
	 * @return	the similarity between them.
	 */
	public double similarityOfTwoTerms(String word, String api) {
		
		if (termVecMap == null) {
			System.out.println("Please load the vector dictionary first");
			return 0.0;
		}
		
		if (!Tools.checkJavaApi(api)) {
			System.out.println(api+" may not be a Java core API");
			return 0.0;
		}
		
		Double[] vec1 = termVecMap.get(new Stemmer().porterStem(word.toLowerCase()));
		Double[] vec2 = termVecMap.get(api);
		
		if (vec1 == null || vec2 == null) {
			System.out.println(word +" or "+ api +" does not in the dictionary");
			return 0.0;
		}
		
		return this.getVecSimilairty(vec1, vec2);
	}
	
	/**
	 * Calculate the similarity between a set of words and a set of APIs
	 * @param words	the set of words. Terms in this set should not be stemmed.
	 * @param apis	the set of APIs (package_name#method_name)
	 * @param idfMap	the idf value of words and APIs. Terms in idfMap should not be stemmed.
	 * @return
	 */
	public double similarityOfTwoTermSets(Set<String> words, Set<String> apis, Map<String, Double> idfMap) {
		
		// word to API similarity
		Double sumSim1 = 0.0, sumIdf1 = 0.0, sum1 = 0.0;
		for (String word : words) {
			Double[] vec1 = termVecMap.get(new Stemmer().porterStem(word.toLowerCase()));
			Double wordIdf = idfMap.get(word);
			if (vec1 == null || wordIdf == null) {
				continue;
			}
			Double max = 0.0;
			for (String api : apis) {
				if (!Tools.checkJavaApi(api)) {
					continue;
				}
				Double[] vec2 = termVecMap.get(api);
				if (vec2 == null) {
					continue;
				}
				
				Double sim = this.getVecSimilairty(vec1, vec2);
				if (max < sim) {
					max = sim;
				}
			}
			sumSim1 += max * wordIdf;
			sumIdf1 += wordIdf;
		}
		if (sumIdf1 < 0.0001) {
			sum1 = 0.0;
		} else {
			sum1 = sumSim1 / sumIdf1;
		}
		
		// API to word similarity
		Double sumSim2 = 0.0, sumIdf2 = 0.0, sum2 = 0.0;
		for (String api : apis) {
			if (!Tools.checkJavaApi(api)) {
				continue;
			}
			Double[] vec1 = termVecMap.get(api);
			Double apiIdf = idfMap.get(api);
			if (vec1 == null || apiIdf == null) {
				continue;
			}
			Double max = 0.0;
			for (String word : words) {
				Double[] vec2 = termVecMap.get(new Stemmer().porterStem(word.toLowerCase()));
				if (vec2 == null) {
					continue;
				}
				Double sim = this.getVecSimilairty(vec1, vec2);
				if (max < sim) {
					max = sim;
				}
			}
			sumSim2 += max * apiIdf;
			sumIdf2 += apiIdf;
		}
		if (sumIdf2 < 0.0001) {
			sum2 = 0.0;
		} else {
			sum2 = sumSim2 / sumIdf2;
		}
		return (sum1 + sum2) / 2;
	}
		
	public static void main(String[] args) {
		
		W2ASimilarity w2a = new W2ASimilarity();
		try {
			String dicPath = "D:\\desktop\\java.dic";
			w2a.loadVecDictionary(dicPath);
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		// similarity between a word and an API.
		String word = "uuid";
		String api = "java.util.UUID#randomUUID";
		System.out.println("The similarity between "+word+" and "+api+" is "+ w2a.similarityOfTwoTerms(word, api));
	
		// similarity between a set of words and a set of APIs.
		Set<String> words = new HashSet<String>() {
			{
				add("test");
				add("file");
				add("exists");
			}
		};
		Set<String> apis = new HashSet<String>() {
			{
				add("java.io.File#exists");
			}
		};
		Map<String, Double> idfMap = new HashMap<String, Double>() {
			{
				put("test", 0.2);
				put("file", 0.1);
				put("exists", 0.3);
				put("java.io.File#exists", 0.4);
			}
		};
		System.out.println("The similarity between the current words and APIs are "+w2a.similarityOfTwoTermSets(words, apis, idfMap));
	}
		
}
